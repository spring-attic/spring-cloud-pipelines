// Do not edit this file (e.g. go instead to docs/)
:jenkins-root-docs: https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs/img/jenkins
:demo-root-docs: https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs/img/demo
:concourse-root-docs: https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs/img/concourse
:intro-root-docs: https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs/img/intro
// remove::start[CF]
[[concourse-pipeline-cf]]
== Concourse Pipeline (Cloud Foundry)

IMPORTANT: In this chapter we assume that you perform deployment of your application
to Cloud Foundry PaaS

[[concourse]] The Spring Cloud Pipelines repository contains opinionated
Concourse pipeline definition. Those jobs will form an empty pipeline and a
sample, opinionated one that you can use in your company.

All in all there are the following projects taking part in the whole `microservice setup` for this demo.

- https://github.com/spring-cloud-samples/github-analytics[Github Analytics] - the app that has a REST endpoint and uses messaging. Our business application.
- https://github.com/spring-cloud-samples/github-webhook[Github Webhook] - project that emits messages that are used by Github Analytics. Our business application.
- https://github.com/spring-cloud-samples/github-eureka[Eureka] - simple Eureka Server. This is an infrastructure application.
- https://github.com/spring-cloud-samples/github-analytics-stub-runner-boot[Github Analytics Stub Runner Boot] - Stub Runner Boot server to be used for tests with Github Analytics. Uses Eureka and Messaging. This is an infrastructure application.

[[concourse-pipeline-step-by-step-cf]]
=== Step by step

If you want to just run the demo as far as possible using PCF Dev and Docker Compose

- <<concourse-fork-cf,Fork repos>>
- <<concourse-start-cf,Start Concourse and Artifactory>>
- <<concourse-deploy-cf,Deploy infra to Artifactory>>
- <<concourse-pcfdev-cf,Start PCF Dev (if you don't want to use an existing one)>>
- <<concourse-fly-cf,Setup the `fly` CLI>>
- <<concourse-credentials-cf,Setup your `credentials.yml`>>
- <<concourse-build-cf,Run the seed job>>
- <<concourse-run-cf,Run the `github-webhook` pipeline>>

[[concourse-fork-cf]]
==== Fork repos

There are 4 apps that are composing the pipeline

  - https://github.com/spring-cloud-samples/github-webhook[Github Webhook]
  - https://github.com/spring-cloud-samples/github-analytics/[Github Analytics]
  - https://github.com/spring-cloud-samples/github-eureka[Github Eureka]
  - https://github.com/spring-cloud-samples/github-analytics-stub-runner-boot[Github Stub Runner Boot]

You need to fork only these. That's because only then will your user be able to tag and push the tag to repo.

  - https://github.com/spring-cloud-samples/github-webhook[Github Webhook]
  - https://github.com/spring-cloud-samples/github-analytics/[Github Analytics]

[[concourse-start-cf]]
==== Start Concourse and Artifactory

Concourse + Artifactory can be run locally. To do that just execute the
`start.sh` script from this repo.

[source,bash]
----
git clone https://github.com/spring-cloud/spring-cloud-pipelines
cd spring-cloud-pipelines/concourse
./setup_docker_compose.sh
./start.sh 192.168.99.100
----

The `setup_docker_compose.sh` script should be executed once only to allow
generation of keys.

The `192.168.99.100` param is an example of an external URL of Concourse
(equal to Docker-Machine ip in this example).

Then Concourse will be running on port `8080` and Artifactory `8081`.

[[concourse-deploy-cf]]
===== Deploy the infra JARs to Artifactory

When Artifactory is running, just execute the `tools/deploy-infra.sh` script from this repo.

[source,bash]
----
git clone https://github.com/spring-cloud/spring-cloud-pipelines
cd spring-cloud-pipelines/
./tools/deploy-infra.sh
----

As a result both `eureka` and `stub runner` repos will be cloned, built
and uploaded to Artifactory.

[[concourse-pcfdev-cf]]
==== Start PCF Dev

TIP: You can skip this step if you have CF installed and don't want to use PCF Dev
The only thing you have to do is to set up spaces.

WARNING: It's more than likely that you'll run out of resources when you reach stage step.
Don't worry! Keep calm and <<resources,clear some apps from PCF Dev and continue>>.

You have to download and start PCF Dev. https://pivotal.io/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry-dev/install-pcf-dev[A link how to do it is available here.]

The default credentials when using PCF Dev are:

[source,bash]
----
username: user
password: pass
email: user
org: pcfdev-org
space: pcfdev-space
api: api.local.pcfdev.io
----

You can start the PCF Dev like this:

[source,bash]
----
cf dev start
----

You'll have to create 3 separate spaces (email admin, pass admin)

[source,bash]
----
cf login -a https://api.local.pcfdev.io --skip-ssl-validation -u admin -p admin -o pcfdev-org

cf create-space pcfdev-test
cf set-space-role user pcfdev-org pcfdev-test SpaceDeveloper
cf create-space pcfdev-stage
cf set-space-role user pcfdev-org pcfdev-stage SpaceDeveloper
cf create-space pcfdev-prod
cf set-space-role user pcfdev-org pcfdev-prod SpaceDeveloper
----

You can also execute the `./tools/cf-helper.sh setup-spaces` to do this.

[[concourse-fly-cf]]
==== Setup the `fly` CLI

If you go to Concourse website you should see sth like this:

{nbsp}
{nbsp}

image::{concourse-root-docs}/running_concourse.png[]

{nbsp}
{nbsp}

You can click one of the icons (depending on your OS) to download `fly`, which is the Concourse CLI. Once you've downloaded that (and maybe added to your PATH) you can run:

[source,bash]
----
fly --version
----

If `fly` is properly installed then it should print out the version.

[[concourse-credentials-cf]]
==== Setup your `credentials.yml`

The repo comes with `credentials-sample-cf.yml` which is set up with sample data (most credentials) are set to be applicable for PCF Dev. Copy this file to a new file `credentials.yml` (the file is added to .gitignore so don't worry that you'll push it with your passwords) and edit it as you wish. For our demo just setup:

  - `app-url` - url pointing to your forked `github-webhook` repo
  - `github-private-key` - your private key to clone / tag GitHub repos
  - `repo-with-binaries` - the IP is set to the defaults for Docker Machine. You should update it to point to your setup

If you don't have a Docker Machine just execute `./whats_my_ip.sh` script to
get an external IP that you can pass to your `repo-with-binaries` instead of the default
Docker Machine IP.

Below you can see what environment variables are required by the scripts. To the right hand side you can see the default values for PCF Dev that we set in the `credentials-sample-cf.yml`.

[frame="topbot",options="header,footer"]
|======================
|Property Name  | Property Description | Default value
|PAAS_TEST_API_URL | The URL to the CF Api for TEST env| api.local.pcfdev.io
|PAAS_STAGE_API_URL | The URL to the CF Api for STAGE env | api.local.pcfdev.io
|PAAS_PROD_API_URL | The URL to the CF Api for PROD env | api.local.pcfdev.io
|PAAS_TEST_ORG    | Name of the org for the test env | pcfdev-org
|PAAS_TEST_SPACE_PREFIX  | Prefix of the name of the CF space for the test env to which the app name will be appended | sc-pipelines-test
|PAAS_STAGE_ORG   | Name of the org for the stage env | pcfdev-org
|PAAS_STAGE_SPACE | Name of the space for the stage env | sc-pipelines-stage
|PAAS_PROD_ORG   | Name of the org for the prod env | pcfdev-org
|PAAS_PROD_SPACE | Name of the space for the prod env | sc-pipelines-prod
|REPO_WITH_BINARIES_FOR_UPLOAD | URL to repo with the deployed jars | http://192.168.99.100:8081/artifactory/libs-release-local
|M2_SETTINGS_REPO_ID | The id of server from Maven settings.xml | artifactory-local
|PAAS_HOSTNAME_UUID | Additional suffix for the route. In a shared environment the default routes can be already taken |
|JAVA_BUILDPACK_URL | The URL to the Java buildpack to be used by CF | https://github.com/cloudfoundry/java-buildpack.git#v3.8.1 |
|BUILD_OPTIONS | Additional options you would like to pass to the Maven / Gradle build |
|======================

[[concourse-build-cf]]
==== Build the pipeline

Log in (e.g. for Concourse running at `192.168.99.100` - if you don't provide any value then `localhost` is assumed). If you execute this script  (it assumes that either `fly` is on your `PATH` or it's in the same folder as the script is):

[source,bash]
----
./login.sh 192.168.99.100
----

Next run the command to create the pipeline.

[source,bash]
----
./set_pipeline.sh
----

Then you'll create a `github-webhook` pipeline under the `docker` alias, using the provided `credentials.yml` file.
You can override these values in exactly that order (e.g. `./set-pipeline.sh some-project another-target some-other-credentials.yml`)

[[concourse-run-cf]]
==== Run the `github-webhook` pipeline

{nbsp}
{nbsp}

image::{concourse-root-docs}/concourse_login.png[caption="Step 1: ", title="Click `Login`"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/concourse_team_main.png[caption="Step 2: ", title="Pick `main` team"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/concourse_user_pass.png[caption="Step 3: ", title="Log in with `concourse` user and `changeme` password"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/concourse_pipeline.png[caption="Step 4: ", title="Your screen should look more or less like this"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/start_pipeline.png[caption="Step 5: ", title="Unpause the pipeline by clicking in the top lefr corner and then clicking the `play` button"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/generate_version.png[caption="Step 6: ", title="Click 'generate-version'"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/run_pipeline.png[caption="Step 7: ", title="Click `+` sign to start a new build"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/concourse_pending.png[caption="Step 8: ", title="The job is pending"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/job_running.png[caption="Step 9: ", title="Job is pending in the main screen"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/running_pipeline.png[caption="Step 10: ", title="Job is running in the main screen"]
// remove::end[CF]

// remove::start[K8S]
[[concourse-pipeline-k8s]]
== Concourse Pipeline (Kubernetes)

IMPORTANT: In this chapter we assume that you perform deployment of your application
to Kubernetes PaaS

[[concourse]] The Spring Cloud Pipelines repository contains opinionated
Concourse pipeline definition. Those jobs will form an empty pipeline and a
sample, opinionated one that you can use in your company.

All in all there are the following projects taking part in the whole `microservice setup` for this demo.

- https://github.com/spring-cloud-samples/github-analytics-kubernetes[Github Analytics] - the app that has a REST endpoint and uses messaging. Our business application.
- https://github.com/spring-cloud-samples/github-webhook-kubernetes[Github Webhook] - project that emits messages that are used by Github Analytics. Our business application.
- https://github.com/spring-cloud-samples/github-eureka[Eureka] - simple Eureka Server. This is an infrastructure application.
- https://github.com/spring-cloud-samples/github-analytics-stub-runner-boot[Github Analytics Stub Runner Boot] - Stub Runner Boot server to be used for tests with Github Analytics. Uses Eureka and Messaging. This is an infrastructure application.

[[step-by-step-k8s]]
=== Step by step

This is a guide for Concourse pipeline.

If you want to just run the demo as far as possible using PCF Dev and Docker Compose

- <<concourse-fork-k8s,Fork repos>>
- <<concourse-start-k8s,Start Concourse and Artifactory>>
- <<concourse-pipeline-fly-k8s,Setup the `fly` CLI >>
- <<concourse-pipeline-credentials-k8s,Setup your `credentials.yml` >>
- <<concourse-pipeline-build-k8s,Setup the pipeline >>
- <<concourse-pipeline-run-k8s,Run the `github-webhook` pipeline>>

[[fork-repos-k8s]]
==== Fork repos

[[concourse-fork-k8s]] There are 4 apps that are composing the pipeline

  - https://github.com/spring-cloud-samples/github-webhook-kubernetes[Github Webhook]
  - https://github.com/spring-cloud-samples/github-analytics-kubernetes/[Github Analytics]
  - https://github.com/spring-cloud-samples/github-eureka[Github Eureka]
  - https://github.com/spring-cloud-samples/github-analytics-stub-runner-boot-classpath-stubs[Github Stub Runner Boot]

You need to fork only these. That's because only then will your user be able to tag and push the tag to repo.

  - https://github.com/spring-cloud-samples/github-webhook-kubernetes[Github Webhook]
  - https://github.com/spring-cloud-samples/github-analytics-kubernetes/[Github Analytics]

[[concourse-start-k8s]]
=== Concourse in K8S (Kubernetes)

The simplest way to deploy Concourse to K8S is to use https://github.com/kubernetes/helm[Helm].
Once you have Helm installed and your `kubectl` is pointing to the
cluster, just type this command to install the Concourse cluster in your K8S cluster.

[source,bash]
----
$ helm install stable/concourse --name concourse
----

Once it's done you'll see the following output

[source,bash]
----
1. Concourse can be accessed:

  * Within your cluster, at the following DNS name at port 8080:

    concourse-web.default.svc.cluster.local

  * From outside the cluster, run these commands in the same shell:

    export POD_NAME=$(kubectl get pods --namespace default -l "app=concourse-web" -o jsonpath="{.items[0].metadata.name}")
    echo "Visit http://127.0.0.1:8080 to use Concourse"
    kubectl port-forward --namespace default $POD_NAME 8080:8080

2. Login with the following credentials

  Username: concourse
  Password: concourse
----

Just follow these steps and log in to Concourse under http://127.0.0.1:8080.

==== Deploying Artifactory to K8S

We can use Helm also to deploy Artifactory to K8S

[source,bash]
----
$ helm install --name artifactory --set artifactory.image.repository=docker.bintray.io/jfrog/artifactory-oss stable/artifactory
----

After executing this you'll see the following output

[source,bash]
----
NOTES:
Congratulations. You have just deployed JFrog Artifactory Pro!

1. Get the Artifactory URL by running these commands:

   NOTE: It may take a few minutes for the LoadBalancer IP to be available.
         You can watch the status of the service by running 'kubectl get svc -w nginx'
   export SERVICE_IP=$(kubectl get svc --namespace default nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
   echo http://$SERVICE_IP/

2. Open Artifactory in your browser
   Default credential for Artifactory:
   user: admin
   password: password
----

Next, we need to set up the repositories.

First, access the Artifactory URL and log in with
user, `admin` and `password` password.

image::{concourse-root-docs}/artifactory_quick_setup.png[title="Click on the `Quick Setup`"]

Then, click on the Maven setup and click `Create`.

image::{concourse-root-docs}/artifactory_maven_repo.png[title="Create the `Maven` Repository"]

[[concourse-pipeline-fly-k8s]]
==== Setup the `fly` CLI

[[fly]] If you go to Concourse website you should see sth like this:

{nbsp}
{nbsp}

image::{concourse-root-docs}/running_concourse.png[]

{nbsp}
{nbsp}

You can click one of the icons (depending on your OS) to download `fly`, which is the Concourse CLI. Once you've downloaded that (and maybe added to your PATH) you can run:

[source,bash]
----
fly --version
----

If `fly` is properly installed then it should print out the version.

[[concourse-pipeline-credentials-k8s]]
==== Setup your `credentials.yml`

There is a sample credentials file called `credentials-sample-k8s.yml`
prepared for `k8s`. You can use it as a base for your `credentials.yml`.

To allow the Concourse worker's spawned container to connect to
Kubernetes cluster you will need to pass the CA contents and the
auth token.

To get the contents of CA for GCE just execute

[source,bash]
----
$ kubectl get secret $(kubectl get secret | grep default-token | awk '{print $1}') -o jsonpath='{.data.ca\.crt}' | base64 --decode
----

To get the token just type:

[source,bash]
----
$ kubectl get secret $(kubectl get secret | grep default-token | awk '{print $1}') -o jsonpath='{.data.token}' | base64 --decode
----

Set that value under `paas-test-client-token`, `paas-stage-client-token` and `paas-prod-client-token`

[[concourse-pipeline-build-k8s]]
==== Build the pipeline

After running Concourse you should get the following output in your terminal

[source,bash]
----
$ export POD_NAME=$(kubectl get pods --namespace default -l "app=concourse-web" -o jsonpath="{.items[0].metadata.name}")
$ echo "Visit http://127.0.0.1:8080 to use Concourse"
$ kubectl port-forward --namespace default $POD_NAME 8080:8080
Visit http://127.0.0.1:8080 to use Concourse
----

Log in (e.g. for Concourse running at `127.0.0.1` - if you don't provide any value then `localhost` is assumed). If you execute this script  (it assumes that either `fly` is on your `PATH` or it's in the same folder as the script is):

[source,bash]
----
$ fly -t k8s login -c http://localhost:8080 -u concourse -p concourse
----

Next run the command to create the pipeline.

[source,bash]
----
$ ./set_pipeline.sh github-webhook k8s credentials-k8s.yml
----

[[concourse-pipeline-run-k8s]]
==== Run the `github-webhook` pipeline

{nbsp}
{nbsp}

image::{concourse-root-docs}/concourse_login.png[caption="Step 1: ", title="Click `Login`"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/concourse_team_main.png[caption="Step 2: ", title="Pick `main` team"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/concourse_user_pass.png[caption="Step 3: ", title="Log in with `concourse` user and `concourse` password"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/concourse_pipeline.png[caption="Step 4: ", title="Your screen should look more or less like this"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/start_pipeline.png[caption="Step 5: ", title="Unpause the pipeline by clicking in the top lefr corner and then clicking the `play` button"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/generate_version.png[caption="Step 6: ", title="Click 'generate-version'"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/run_pipeline.png[caption="Step 7: ", title="Click `+` sign to start a new build"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/concourse_pending.png[caption="Step 8: ", title="The job is pending"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/job_running.png[caption="Step 9: ", title="Job is pending in the main screen"]

{nbsp}
{nbsp}

image::{concourse-root-docs}/running_pipeline.png[caption="Step 10: ", title="Job is running in the main screen"]

// remove::end[K8S]

[[concourse-faq]]
== Concourse FAQ

=== Can I use the pipeline for some other repos?

Sure! Just change the `app-url` in `credentials.yml`!

=== Will this work for ANY project out of the box?

Not really. This is an `opinionated pipeline` that's why we took some
opinionated decisions. Check out the documentation to see
what those decisions are.

=== Can I modify this to reuse in my project?

Sure! It's open-source! The important thing is that the core part of the logic is written in
Bash scripts. That way, in the majority of cases, you could change only the bash scripts without changing the
whole pipeline. https://github.com/spring-cloud/spring-cloud-pipelines/tree/master/common/src/main/bash[You can check out the scripts here.]

Furthermore, if you only want to customize a particular function under `common/src/main/bash`, you can provide your own
function under `common/src/main/bash/<some custom identifier>` where `<some custom identifier>` is equal to the value of
the `CUSTOM_SCRIPT_IDENTIFIER` environment variable. It defaults to `custom`.

=== I ran out of resources!! (PCF Dev)

[[resources]] When deploying the app to stage or prod you can get an exception `Insufficient resources`. The way to
 solve it is to kill some apps from test / stage env. To achieve that just call

[source,bash]
----
cf target -o pcfdev-org -s pcfdev-test
cf stop github-webhook
cf stop github-eureka
cf stop stubrunner
----

You can also execute `./tools/cf-helper.sh kill-all-apps` that will remove
all demo-related apps deployed to PCF Dev.

=== The rollback step fails due to missing JAR ?!

You must have pushed some tags and have removed the Artifactory volume that
contained them. To fix this, just remove the tags

[source,bash]
----
git tag -l | xargs -n 1 git push --delete origin
----

=== Can I see the output of a job from the terminal?

Yes! Assuming that pipeline name is `github-webhook` and job name is `build-and-upload` you can running

[source,bash]
----
fly watch --job github-webhook/build-and-upload -t docker
----

=== I clicked the job and it's constantly pending...

Don't worry... most likely you've just forgotten to click the `play` button to
unpause the pipeline. Click to the top left, expand the list of pipelines and click
the `play` button next to `github-webhook`.

Another problem that might occur is that you need to have the `version` branch.
Concourse will wait for the `version` branch to appear in your repo. So in order for
the pipeline to start ensure that when doing some git operations you haven't
forgotten to create / copy the `version` branch too.

=== The route is already in use (CF)

If you play around with Jenkins / Concourse you might end up with the routes occupied

[source,bash]
----
Using route github-webhook-test.local.pcfdev.io
Binding github-webhook-test.local.pcfdev.io to github-webhook...
FAILED
The route github-webhook-test.local.pcfdev.io is already in use.
----

Just delete the routes

[source,bash]
----
yes | cf delete-route local.pcfdev.io -n github-webhook-test
yes | cf delete-route local.pcfdev.io -n github-eureka-test
yes | cf delete-route local.pcfdev.io -n stubrunner-test
yes | cf delete-route local.pcfdev.io -n github-webhook-stage
yes | cf delete-route local.pcfdev.io -n github-eureka-stage
yes | cf delete-route local.pcfdev.io -n github-webhook-prod
yes | cf delete-route local.pcfdev.io -n github-eureka-prod
----

You can also execute the `./tools/cf-helper.sh delete-routes`

=== I'm unauthorized to deploy infrastructure jars

Most likely you've forgotten to update your local `settings.xml` with the Artifactory's
setup. Check out <<settings,this section of the docs and update your `settings.xml`>>.

=== `version` resource is broken

When I click on it it looks like this:

[source,bash]
----
resource script '/opt/resource/check []' failed: exit status 128

stderr:
Identity added: /tmp/git-resource-private-key (/tmp/git-resource-private-key)
Cloning into '/tmp/git-resource-repo-cache'...
warning: Could not find remote branch version to clone.
fatal: Remote branch version not found in upstream origin
----

That means that your repo doesn't have the `version` branch. Please
set it up.