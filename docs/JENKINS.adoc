== Jenkins DSL Pipeline

[[jenkins]] The repository contains job definitions and the opinionated setup pipeline using https://wiki.jenkins-ci.org/display/JENKINS/Job+DSL+Plugin[Jenkins Job Dsl plugin]. Those jobs will form an empty pipeline and a sample, opinionated one that you can use in your company.

All in all there are the following projects taking part in the whole `microservice setup` for this demo.

- https://github.com/spring-cloud-samples/github-analytics[Github-Analytics] - the app that has a REST endpoint and uses messaging. Our business application.
- https://github.com/spring-cloud-samples/github-webhook[Github Webhook] - project that emits messages that are used by Github Analytics. Our business application.
- https://github.com/spring-cloud-samples/github-eureka[Eureka] - simple Eureka Server. This is an infrastructure application.
- https://github.com/spring-cloud-samples/github-analytics-stub-runner-boot[Github Analytics Stub Runner Boot] - Stub Runner Boot server to be used for tests with Github Analytics. Uses Eureka and Messaging. This is an infrastructure application.

=== Project setup

[source,bash]
----
.
├── jobs
│   ├── jenkins_pipeline_empty.groovy
│   ├── jenkins_pipeline_jenkinsfile_empty.groovy
│   ├── jenkins_pipeline_sample.groovy
│   └── jenkins_pipeline_sample_view.groovy
├── seed
│   ├── gradle.properties
│   ├── init.groovy
│   ├── jenkins_pipeline.groovy
│   └── settings.xml
└── src
    ├── main
    └── test
----

In the `jobs` folder you have all the seed jobs that will generate pipelines.

- `jenkins_pipeline_empty.groovy` - is a template of a pipeline with empty steps using the Jenkins Job DSL plugin
- `jenkins_pipeline_jenkinsfile_empty.groovy` - is a template of a pipeline with empty steps using the Pipeline plugin
- `jenkins_pipeline_sample.groovy` - is an opinionated implementation using the Jenkins Job DSL plugin
- `jenkins_pipeline_sample_view.groovy` - builds the views for the pipelines

In the `seed` folder you have the `init.groovy` file which is executed when Jenkins starts.
That way we can configure most of Jenkins options for you (adding credentials, JDK etc.).
`jenkins_pipeline.groovy` contains logic to build a seed job (that way you don't have to even click that
job - we generate it for you).

In the `src` folder you have production and test classes needed for you to build your own pipeline.
Currently we have tests only cause the whole logic resides in the `jenkins_pipeline_sample` file.

=== Step by step

If you want to just run the demo as far as possible using PCF Dev and Docker Compose

- <<jenkins_fork,Fork repos>>
- <<jenkins_start,Start Jenkins and Artifactory>>
- <<jenkins_deploy,Deploy infra to Artifactory>>
- <<jenkins_pcfdev,Start PCF Dev (if you don't want to use an existing one)>>
- <<jenkins_seed,Run the seed job>>
- <<jenkins_pipeline,Run the `github-webhook` pipeline>>

Below you can find <<optional,optional>> steps needed to be taken when you want to customize the pipeline

- <<env,Setup Jenkins env vars (if you want to use the demo defaults and you're using Docker Machine
just check out the section on how to update the URL to Artifactory)>>
- <<jenkins_settings,Add `settings.xml` for Jenkins' master (you can skip this if you want to use our defaults)>>
- <<jenkins_misc,Setup Jenkins miscs (JDK installation, Groovy macro processing etc.)>>
- <<jenkins_credentials,Setup Jenkins credentials>>

==== Fork repos

[[jenkins_fork]] There are 4 apps that are composing the pipeline

  - https://github.com/spring-cloud-samples/github-webhook[Github Webhook]
  - https://github.com/spring-cloud-samples/github-analytics/[Github Analytics]
  - https://github.com/spring-cloud-samples/github-eureka[Github Eureka]
  - https://github.com/spring-cloud-samples/github-analytics-stub-runner-boot[Github Stub Runner Boot]

You need to fork only these. That's because only then will your user be able to tag and push the tag to repo.

  - https://github.com/spring-cloud-samples/github-webhook[Github Webhook]
  - https://github.com/spring-cloud-samples/github-analytics/[Github Analytics]

==== Start Jenkins and Artifactory

[[jenkins_start]] Jenkins + Artifactory can be ran locally. To do that just execute the
`start.sh` script from this repo.

[source,bash]
----
git clone https://github.com/spring-cloud/spring-cloud-pipelines
cd spring-cloud-pipelines/jenkins
./start.sh yourGitUsername yourGitPassword yourForkedGithubOrg
----
Then Jenkins will be running on port `8080` and Artifactory `8081`.
The provided parameters will be passed as env variables to Jenkins VM
and credentials will be set in your set. That way you don't have to do
any manual work on the Jenkins side. In the above parameters, the third parameter
could be yourForkedGithubOrg or yourGithubUsername. Also the `REPOS` env variable will
contain your GitHub org in which you have the forked repos.

===== Deploy the infra JARs to Artifactory

[[jenkins_deploy]] When Artifactory is running, just execute the `tools/deploy-infra.sh` script from this repo.

[source,bash]
----
git clone https://github.com/spring-cloud/spring-cloud-pipelines
cd spring-cloud-pipelines/
./tools/deploy-infra.sh
----

As a result both `eureka` and `stub runner` repos will be cloned, built
and uploaded to Artifactory.

==== Start PCF Dev

TIP: You can skip this step if you have CF installed and don't want to use PCF Dev
The only thing you have to do is to set up spaces.

WARNING: It's more than likely that you'll run out of resources when you reach stage step.
Don't worry! Keep calm and <<resources,clear some apps from PCF Dev and continue>>.

[[jenkins_pcfdev]] You have to download and start PCF Dev. https://pivotal.io/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry-dev/install-pcf-dev[A link how to do it is available here.]

The default credentials when using PCF Dev are:

[source,bash]
----
username: user
password: pass
email: user
org: pcfdev-org
space: pcfdev-space
api: api.local.pcfdev.io
----

You can start the PCF dev like this:

[source,bash]
----
cf dev start
----

You'll have to create 3 separate spaces (email admin, pass admin)

[source,bash]
----
cf login -a https://api.local.pcfdev.io --skip-ssl-validation -u admin -p admin -o pcfdev-org

cf create-space pcfdev-test
cf set-space-role user pcfdev-org pcfdev-test SpaceDeveloper
cf create-space pcfdev-stage
cf set-space-role user pcfdev-org pcfdev-stage SpaceDeveloper
cf create-space pcfdev-prod
cf set-space-role user pcfdev-org pcfdev-prod SpaceDeveloper
----

You can also execute the `./setup_spaces.sh` script to do this.

==== Run the seed job

[[jenkins_seed]] We already create the seed job for you but you'll have to run it. When you do
run it you have to provide some properties. By default we create a seed that
has all the properties options, but you can delete most of it. If you
set the properties as global env variables you have to remove them from the
seed.

Anyways, to run the demo just provide in the `REPOS` var the comma separated
 list of URLs of the 2 aforementioned forks of `github-webhook` and `github-analytics'.

{nbsp}
{nbsp}

image::{jenkins-root-docs}/seed_click.png[caption="Step 1: ", title="Click the 'jenkins-pipeline-seed' job"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/seed_run.png[caption="Step 2: ", title="Click the 'Build with parameters'"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/seed.png[caption="Step 3: ", title="Provide the `REPOS` parameter with URLs of your forks (you'll have more properties than the ones in the screenshot)"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/seed_built.png[caption="Step 4: ", title="This is how the results of seed should look like"]

==== Run the `github-webhook` pipeline

[[jenkins_pipeline]] We already create the seed job for you but you'll have to run it. When you do
run it you have to provide some properties. By default we create a seed that
has all the properties options, but you can delete most of it. If you
set the properties as global env variables you have to remove them from the
seed.

Anyways, to run the demo just provide in the `REPOS` var the comma separated
 list of URLs of the 2 aforementioned forks of `github-webhook` and `github-analytics`.

{nbsp}
{nbsp}

image::{jenkins-root-docs}/seed_views.png[caption="Step 1: ", title="Click the 'github-webhook' view"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/pipeline_run.png[caption="Step 2: ", title="Run the pipeline"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/pipeline_run_props.png[caption="Step 3: ", title="You can set some properties (just click 'Build' to proceed) "]

{nbsp}
{nbsp}

IMPORTANT: Most likely your 1st build will suddenly hang for 10 minutes. If you rerun it
again it should work after 2-3 minutes. My guess is that it's related to Docker Compose
so sorry for this unfortunate situation.

IMPORTANT: If your build fails on the *deploy previous version to stage* due to missing jar,
that means that you've forgotten to clear the tags in your repo. Typically that's due to the fact that
you've removed the Artifactory volume with deployed JAR whereas a tag in the repo is still pointing there.
<<tags,Check out this section on how to remove the tag.>>

{nbsp}
{nbsp}

image::{jenkins-root-docs}/pipeline_manual.png[caption="Step 4: ", title="Click the manual step to go to stage (remember about killing the apps on test env). To do this click the *ARROW* next to the job name"]

{nbsp}
{nbsp}

IMPORTANT: Most likely you will run out of memory so when reaching the stage
environment it's good to kill all apps on test. <<faq,Check out the FAQ section for more details>>!

{nbsp}
{nbsp}

image::{jenkins-root-docs}/pipeline_finished.png[caption="Step 5: ", title="The full pipeline should look like this"]

{nbsp}
{nbsp}

=== Optional steps

[[jenkins_optional]] All the steps below are not necessary to run the demo. They are needed only
when you want to do some custom changes.

==== Deploying infra jars to a different location

It's enough to set the `ARTIFACTORY_URL` environmental variable before
executing `tools/deploy-infra.sh`. Example for deploying to Artifactory at IP `192.168.99.100`

[source,bash]
----
git clone https://github.com/spring-cloud/spring-cloud-pipelines
cd spring-cloud-pipelines/
ARTIFACTORY_URL="http://192.168.99.100:8081/artifactory/libs-release-local" ./tools/deploy-infra.sh
----

==== Setup settings.xml for Maven deployment

TIP: If you want to use the default connection to the Docker version
of Artifactory you can skip this step

[[jenkins_settings]] So that `./mvnw deploy` works with Artifactory from Docker we're
already copying the missing `settings.xml` file for you. It looks like this:

[source,xml]
----
<server>
  <id>artifactory-local</id>
  <username>admin</username>
  <password>password</password>
</server>
----

If you want to use your own version of Artifactory / Nexus you have to update
the file (it's in `seed/settings.xml`).

==== Setup Jenkins env vars

[[jenkins_env]] If you want to only play around with the demo that we've prepared you have to set *ONE* variable which is the `REPOS` variable.
That variable needs to consists of comma separated list of URLs to repositories containing business apps. So you should pass your forked repos URLs.

You can do it in the following ways:

- globally via Jenkins global env vars (then when you run the seed that variable will be taken into consideration and proper pipelines will get built)
- modify the seed job parameters (you'll have to modify the seed job configuration and change the `REPOS` property)
- provide the repos parameter when running the seed job

For the sake of simplicity let's go with the *last* option.

IMPORTANT: If you're choosing the global envs, you *HAVE* to remove the other approach
(e.g. if you set the global env for `REPOS`, please remove that property in the
seed job

===== Seed properties

Click on the seed job and pick `Build with parameters`. Then as presented in the screen below (you'll have far more properties to set) just modify the `REPOS` property by providing the comma separated list of URLs to your forks. Whatever you set will be parsed by the seed job and passed to the generated Jenkins jobs.

TIP: This is very useful when the repos you want to build differ. E.g. use
different JDK. Then some seeds can set the `JDK_VERSION` param to one version
of Java installation and the others to another one.

Example screen:

image::{jenkins-root-docs}/seed.png[]

In the screenshot we could parametrize the `REPOS` and `REPO_WITH_JARS` params.

===== Global envs

IMPORTANT: This section is presented only for informational purposes - for the sake of demo you can skip it

You can add env vars (go to configure Jenkins -> Global Properties) for the following
 properties (the defaults are for PCF Dev):

Example screen:

image::{jenkins-root-docs}/env_vars.png[]

===== All env vars

The env vars that are used in all of the jobs are as follows:

[frame="topbot",options="header,footer"]
|======================
|Property Name  | Property Description | Default value
|CF_TEST_API_URL | The URL to the CF Api for TEST env| api.local.pcfdev.io
|CF_STAGE_API_URL | The URL to the CF Api for STAGE env | api.local.pcfdev.io
|CF_PROD_API_URL | The URL to the CF Api for PROD env | api.local.pcfdev.io
|CF_TEST_ORG    | Name of the org for the test env | pcfdev-org
|CF_TEST_SPACE  | Name of the space for the test env | pcfdev-space
|CF_STAGE_ORG   | Name of the org for the stage env | pcfdev-org
|CF_STAGE_SPACE | Name of the space for the stage env | pcfdev-space
|CF_PROD_ORG   | Name of the org for the prod env | pcfdev-org
|CF_PROD_SPACE | Name of the space for the prod env | pcfdev-space
|REPO_WITH_JARS | URL to repo with the deployed jars | http://artifactory:8081/artifactory/libs-release-local
|M2_SETTINGS_REPO_ID | The id of server from Maven settings.xml | artifactory-local
|JDK_VERSION | The name of the JDK installation | jdk8
|PIPELINE_VERSION | What should be the version of the pipeline (ultimately also version of the jar) | 1.0.0.M1-${GROOVY,script ="new Date().format('yyMMdd_HHmmss')"}-VERSION
|GIT_EMAIL | The email used by Git to tag repo | email@example.com
|GIT_NAME | The name used by Git to tag repo | Pivo Tal
|======================

==== Set Git email / user

Since our pipeline is setting the git user / name explicitly for the build step
 you'd have to go to `Configure` of the build step and modify the Git name / email.
 If you want to set it globally you'll have to remove the section from the build
 step and follow these steps to set it globally.

You can set Git email / user globally like this:

{nbsp}
{nbsp}

image::{jenkins-root-docs}/manage_jenkins.png[caption="Step 1: ", title="Click 'Manage Jenkins'"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/configure_system.png[caption="Step 2: ", title="Click 'Configure System'"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/git.png[caption="Step 3: ", title="Fill out Git user information"]

{nbsp}
{nbsp}

==== Jenkins Credentials

In your scripts we reference the credentials via IDs. These are the defaults for credentials

[frame="topbot",options="header,footer"]
|======================
|Property Name  | Property Description | Default value
|GIT_CREDENTIAL_ID    | Credential ID used to tag a git repo | git
|CF_TEST_CREDENTIAL_ID  | Credential ID for CF Test env access | cf-test
|CF_STAGE_CREDENTIAL_ID   | Credential ID for CF Stage env access | cf-stage
|CF_PROD_CREDENTIAL_ID | Credential ID for CF Prod env access | cf-prod
|======================

If you already have in your system a credential to for example tag a repo
you can use it by passing the value of the property `GIT_CREDENTIAL_ID`

===== Add Jenkins credentials for GitHub

[[jenkins_credentials]] The scripts will need to access the credential in order to tag the repo.

You have to set credentials with id: `git`.

Below you can find instructions on how to set a credential (e.g. for `cf-test` credential but
remember to provide the one with id `git`).

{nbsp}
{nbsp}

image::{jenkins-root-docs}/credentials_system.png[caption="Step 1: ", title="Click 'Credentials, System'"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/credentials_global.png[caption="Step 2: ", title="Click 'Global Credentials'"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/credentials_add.png[caption="Step 3: ", title="Click 'Add credentials'"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/credentials_example.png[caption="Step 4: ", title="Fill out the user / password and provide the `git` credential ID (in this example `cf-test`)"]

{nbsp}
{nbsp}

==== Enable Groovy Token Macro Processing

With scripted that but if you needed to this manually then this is how to do it:

{nbsp}
{nbsp}

image::{jenkins-root-docs}/manage_jenkins.png[caption="Step 1: ", title="Click 'Manage Jenkins'"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/configure_system.png[caption="Step 2: ", title="Click 'Configure System'"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/groovy_token.png[caption="Step 3: ", title="Click 'Allow token macro processing'"]

=== Docker Image
If you would like to run the pre-configured Jenkins image somewhere other than your local machine, we
have an image you can pull and use on https://hub.docker.com/r/springcloud/spring-cloud-pipeline-jenkins/[DockerHub].
The `latest` tag corresponds to the latest snapshot build.  You can also find tags
corresponding to stable releases that you can use as well. 

=== FAQ

[[jenkins_faq]]

==== Pipeline version contains ${PIPELINE_VERSION}

You can check the Jenkins logs and you'll see

[source,bash]
----
WARNING: Skipped parameter `PIPELINE_VERSION` as it is undefined on `jenkins-pipeline-sample-build`.
	Set `-Dhudson.model.ParametersAction.keepUndefinedParameters`=true to allow undefined parameters
	to be injected as environment variables or
	`-Dhudson.model.ParametersAction.safeParameters=[comma-separated list]`
	to whitelist specific parameter names, even though it represents a security breach
----

To fix it you have to do exactly what the warning suggests... Also ensure that the `Groovy token macro processing`
checkbox is set.

==== Pipeline version is not passed to the build

You can see that the Jenkins version is properly set but in the build version is still snapshot and
the `echo "${PIPELINE_VERSION}"` doesn't print anything.

You can check the Jenkins logs and you'll see

[source,bash]
----
WARNING: Skipped parameter `PIPELINE_VERSION` as it is undefined on `jenkins-pipeline-sample-build`.
	Set `-Dhudson.model.ParametersAction.keepUndefinedParameters`=true to allow undefined parameters
	to be injected as environment variables or
	`-Dhudson.model.ParametersAction.safeParameters=[comma-separated list]`
	to whitelist specific parameter names, even though it represents a security breach
----

To fix it you have to do exactly what the warning suggests...

==== The build times out with `pipeline.sh` info

Docker compose, docker compose, docker compose... The problem is that for some reason, only in Docker, the execution of
Java hangs. But it hangs randomly and only the first time you try to execute the pipeline.

The solution to this is to run the pipeline again. If once it suddenly, magically passes then
it will pass for any subsequent build.

Another thing that you can try is to run it with plain Docker. Maybe that will help.

==== Can I use the pipeline for some other repos?

Sure! you can pass `REPOS` variable with comma separated list of
`project_name$project_url` format. If you don't provide the PROJECT_NAME the
repo name will be extracted and used as the name of the project.

E.g. for `REPOS` equal to:

`https://github.com/spring-cloud-samples/github-analytics,https://github.com/spring-cloud-samples/github-webhook`

will result in the creation of pipelines with root names `github-analytics` and `github-webhook`.

E.g. for `REPOS` equal to:

`foo$https://github.com/spring-cloud-samples/github-analytics,bar$https://github.com/spring-cloud-samples/atom-feed`

will result in the creation of pipelines with root names `foo` for `github-analytics`
and `bar` for `github-webhook`.

==== Will this work for ANY project out of the box?

Not really. This is an `opinionated pipeline` that's why we took some
opinionated decisions like:

- usage of Spring Cloud, Spring Cloud Contract Stub Runner and Spring Cloud Eureka
- application deployment to Cloud Foundry
- For Maven:
    * usage of Maven Wrapper
    * artifacts deployment by `./mvnw clean deploy`
    * `stubrunner.ids` property to retrieve list of collaborators for which stubs should be downloaded
    * running smoke tests on a deployed app via the `smoke` Maven profile
    * running end to end tests on a deployed app via the `e2e` Maven profile
- For Gradle (in the `github-analytics` application check the `gradle/pipeline.gradle` file):
    * usage of Gradlew Wrapper
    * `deploy` task for artifacts deployment
    * running smoke tests on a deployed app via the `smoke` task
    * running end to end tests on a deployed app via the `e2e` task
    * `groupId` task to retrieve group id
    * `artifactId` task to retrieve artifact id
    * `currentVersion` task to retrieve the current version
    * `stubIds` task to retrieve list of collaborators for which stubs should be downloaded

This is the initial approach that can be easily changed in the future.

==== Can I modify this to reuse in my project?

Sure! It's open-source! The important thing is that the core part of the logic is written
in Bash scripts. That way, in the majority of cases, you could change only the bash
scripts without changing the whole pipeline.

==== I ran out of resources!!

[jenkins_resources]] When deploying the app to stage or prod you can get an exception `Insufficient resources`. The way to
 solve it is to kill some apps from test / stage env. To achieve that just call

[source,bash]
----
cf target -o pcfdev-org -s pcfdev-test
cf stop github-webhook
cf stop github-eureka
cf stop stubrunner
----

You can also execute `kill_all_pcfdev_apps.sh` that will remove all demo-related apps
deployed to PCF dev.

==== The rollback step fails due to missing JAR ?!

[[jenkins_tags]] You must have pushed some tags and have removed the Artifactory volume that
contained them. To fix this, just remove the tags

[source,bash]
----
git tag -l | xargs -n 1 git push --delete origin
----

==== I want to provide a different JDK version

- by default we assume that you have jdk with id `jdk8` configured
- if you want a different one just override `JDK_VERSION` env var and point to the proper one

TIP: The docker image comes in with Java installed at `/usr/lib/jvm/java-8-openjdk-amd64`.
You can go to `Global Tools` and create a JDK with `jdk8` id and JAVA_HOME
 pointing to `/usr/lib/jvm/java-8-openjdk-amd64`

To change the default one just follow these steps:

{nbsp}
{nbsp}

image::{jenkins-root-docs}/manage_jenkins.png[caption="Step 1: ", title="Click 'Manage Jenkins'"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/global_tool.png[caption="Step 2: ", title="Click 'Global Tool'"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/jdk_installation.png[caption="Step 3: ", title="Click 'JDK Installations'"]

{nbsp}
{nbsp}

image::{jenkins-root-docs}/jdk.png[caption="Step 4: ", title="Fill out JDK Installation with path to your JDK"]

{nbsp}
{nbsp}

And that's it!

===== I want deployment to stage and prod be automatic

No problem, just set the property / env var to true

- `AUTO_DEPLOY_TO_STAGE` to automatically deploy to stage
- `AUTO_DEPLOY_TO_PROD` to automatically deploy to prod

==== I can't tag the repo!

When you get sth like this:

[source,bash]
----
19:01:44 stderr: remote: Invalid username or password.
19:01:44 fatal: Authentication failed for 'https://github.com/marcingrzejszczak/github-webhook/'
19:01:44
19:01:44 	at org.jenkinsci.plugins.gitclient.CliGitAPIImpl.launchCommandIn(CliGitAPIImpl.java:1740)
19:01:44 	at org.jenkinsci.plugins.gitclient.CliGitAPIImpl.launchCommandWithCredentials(CliGitAPIImpl.java:1476)
19:01:44 	at org.jenkinsci.plugins.gitclient.CliGitAPIImpl.access$300(CliGitAPIImpl.java:63)
19:01:44 	at org.jenkinsci.plugins.gitclient.CliGitAPIImpl$8.execute(CliGitAPIImpl.java:1816)
19:01:44 	at hudson.plugins.git.GitPublisher.perform(GitPublisher.java:295)
19:01:44 	at hudson.tasks.BuildStepMonitor$3.perform(BuildStepMonitor.java:45)
19:01:44 	at hudson.model.AbstractBuild$AbstractBuildExecution.perform(AbstractBuild.java:779)
19:01:44 	at hudson.model.AbstractBuild$AbstractBuildExecution.performAllBuildSteps(AbstractBuild.java:720)
19:01:44 	at hudson.model.Build$BuildExecution.post2(Build.java:185)
19:01:44 	at hudson.model.AbstractBuild$AbstractBuildExecution.post(AbstractBuild.java:665)
19:01:44 	at hudson.model.Run.execute(Run.java:1745)
19:01:44 	at hudson.model.FreeStyleBuild.run(FreeStyleBuild.java:43)
19:01:44 	at hudson.model.ResourceController.execute(ResourceController.java:98)
19:01:44 	at hudson.model.Executor.run(Executor.java:404)
----

most likely you've passed a wrong password. Check the <<jenkins_credentials,credentials>> section
on how to update your credentials.

==== Deploying to test / stage / prod fails - error finding space

If you receive a similar exception:

[source,bash]
----
20:26:18 API endpoint:   https://api.local.pcfdev.io (API version: 2.58.0)
20:26:18 User:           user
20:26:18 Org:            pcfdev-org
20:26:18 Space:          No space targeted, use 'cf target -s SPACE'
20:26:18 FAILED
20:26:18 Error finding space pcfdev-test
20:26:18 Space pcfdev-test not found
----

It means that you've forgotten to <<jenkins_pcfdev,create the spaces>> in your PCF Dev installation.

==== The route is already in use

If you play around with Jenkins / Concourse you might end up with the routes occupied

[source,bash]
----
Using route github-webhook-test.local.pcfdev.io
Binding github-webhook-test.local.pcfdev.io to github-webhook...
FAILED
The route github-webhook-test.local.pcfdev.io is already in use.
----

Just delete the routes

[source,bash]
----
yes | cf delete-route local.pcfdev.io -n github-webhook-test
yes | cf delete-route local.pcfdev.io -n github-eureka-test
yes | cf delete-route local.pcfdev.io -n stubrunner-test
yes | cf delete-route local.pcfdev.io -n github-webhook-stage
yes | cf delete-route local.pcfdev.io -n github-eureka-stage
yes | cf delete-route local.pcfdev.io -n github-webhook-prod
yes | cf delete-route local.pcfdev.io -n github-eureka-prod
----

You can also execute the `./remove_routes.sh` script

==== I'm unauthorized to deploy infrastructure jars

Most likely you've forgotten to update your local `settings.xml` with the Artifactory's
setup. Check out <<jenkins_settings,this section of the docs and update your `settings.xml`>>.

=== How to build it

`./gradlew clean build`

WARNING: The ran test only checks if your scripts compile.

=== How to work with Jenkins Job DSL plugin

Check out the https://github.com/jenkinsci/job-dsl-plugin/wiki/Tutorial---Using-the-Jenkins-Job-DSL[tutorial].
Provide the link to this repository in your Jenkins installation.

WARNING: Remember that views can be overridden that's why the suggestion is to contain in one script all the logic needed to build a view
 for a single project (check out that `spring_cloud_views.groovy` is building all the `spring-cloud` views).
