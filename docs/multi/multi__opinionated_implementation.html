<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>2.&nbsp;Opinionated implementation</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="multi_spring-cloud-pipelines.html" title="Spring Cloud Pipelines"><link rel="up" href="multi_spring-cloud-pipelines.html" title="Spring Cloud Pipelines"><link rel="prev" href="multi__introduction.html" title="1.&nbsp;Introduction"><link rel="next" href="multi__project_opinions.html" title="3.&nbsp;Project opinions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.&nbsp;Opinionated implementation</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="multi__introduction.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="multi__project_opinions.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_opinionated_implementation" href="#_opinionated_implementation"></a>2.&nbsp;Opinionated implementation</h1></div></div></div><p>For the demo purposes we&#8217;re providing Docker Compose setup with Artifactory and Concourse / Jenkins tools.
Regardless of the picked CD application for the pipeline to pass one needs either</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">a Cloud Foundry instance (for example <a class="link" href="https://run.pivotal.io/" target="_top">Pivotal Web Services</a> or <a class="link" href="https://pivotal.io/pcf-dev" target="_top">PCF Dev</a>)</li><li class="listitem">a Kubernetes cluster (for example <a class="link" href="https://github.com/kubernetes/minikube" target="_top">Minikube</a>)</li><li class="listitem">the infrastructure applications deployed to the JAR hosting application (for the demo we&#8217;re providing Artifactory).</li><li class="listitem"><code class="literal">Eureka</code> for Service Discovery</li><li class="listitem"><code class="literal">Stub Runner Boot</code> for running Spring Cloud Contract stubs.</li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>In the demos we&#8217;re showing you how to first build the <code class="literal">github-webhook</code> project. That&#8217;s because
the <code class="literal">github-analytics</code> needs the stubs of <code class="literal">github-webhook</code> to pass the tests. Below you&#8217;ll find
references to <code class="literal">github-analytics</code> project since it contains more interesting pieces as far as testing
is concerned.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_build" href="#_build"></a>2.1&nbsp;Build</h2></div></div></div><div class="figure"><a name="d0e550" href="#d0e550"></a><p class="title"><b>Figure&nbsp;2.1.&nbsp;Build and upload artifacts</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/build.png" alt="build"></div></div></div><br class="figure-break"><p>In this step we&#8217;re generating a version of the pipeline, next we&#8217;re
 running unit, integration and contract tests. Finally we&#8217;re:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">publishing a fat jar of the application</li><li class="listitem">publishing a Spring Cloud Contract jar containing stubs of the application</li><li class="listitem">for Kubernetes - uploading a Docker image of the application</li></ul></div><p>During this phase we&#8217;re executing a <code class="literal">Maven</code> build using Maven Wrapper or a <code class="literal">Gradle</code> build using Gradle Wrapper
, with unit and integration tests. We&#8217;re also <span class="strong"><strong>tagging</strong></span> the repository with <code class="literal">dev/${version}</code> format. That way in each
subsequent step of the pipeline we&#8217;re able to retrieve the tagged version. Also we know
exactly which version of the pipeline corresponds to which Git hash.</p><p>Once the artifact got built we&#8217;re running API compatibility check.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">we&#8217;re searching for the latest production deployment</li><li class="listitem">we&#8217;re retrieving the contracts that were used by that deployment</li><li class="listitem">from the contracts we&#8217;re generating API tests to see if the current implementation
is fulfilling the HTTP / messaging contracts that the current production deployment
has defined (we&#8217;re checking backward compatibility of the API)</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_test" href="#_test"></a>2.2&nbsp;Test</h2></div></div></div><div class="figure"><a name="d0e600" href="#d0e600"></a><p class="title"><b>Figure&nbsp;2.2.&nbsp;Smoke test and rollback test on test environment</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/test.png" alt="test"></div></div></div><br class="figure-break"><p>Here we&#8217;re</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">starting a RabbitMQ service in PaaS</li><li class="listitem">deploying <code class="literal">Eureka</code> infrastructure application to PaaS</li><li class="listitem">downloading the fat jar from Nexus and we&#8217;re uploading it to PaaS. We want the application
to run in isolation (be surrounded by stubs).</li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>Currently due to port constraints in Cloud Foundry
we cannot run multiple stubbed HTTP services in the cloud so to fix this issue we&#8217;re running
the application with <code class="literal">smoke</code> Spring profile on which you can stub out all HTTP calls to return
a mocked response</p></td></tr></table></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">if the application is using a database then it gets upgraded at this point via Flyway, Liquibase
or any other tool once the application gets started</li><li class="listitem">from the project&#8217;s Maven or Gradle build we&#8217;re extracting <code class="literal">stubrunner.ids</code> property that contains
all the <code class="literal">groupId:artifactId:version:classifier</code> notation of dependant projects for which
the stubs should be downloaded.</li><li class="listitem">then we&#8217;re uploading <code class="literal">Stub Runner Boot</code> and pass the extracted <code class="literal">stubrunner.ids</code> to it. That way
we&#8217;ll have a running application in Cloud Foundry that will download all the necessary stubs
of our application</li><li class="listitem">from the checked out code we&#8217;re running the tests available under the <code class="literal">smoke</code> profile. In the
case of <code class="literal">GitHub Analytics</code> application we&#8217;re triggering a message from the <code class="literal">GitHub Webhook</code>
application&#8217;s stub, that is sent via RabbitMQ to GitHub Analytics. Then we&#8217;re checking if
message count has increased.</li><li class="listitem">once the tests pass we&#8217;re searching for the last production release. Once the application
is deployed to production we&#8217;re tagging it with <code class="literal">prod/${version}</code> tag. If there is no such tag
(there was no production release) there will be no rollback tests executed. If there was
a production release the tests will get executed.</li><li class="listitem">assuming that there was a production release we&#8217;re checking out the code corresponding to that
release (we&#8217;re checking out the tag), we&#8217;re downloading the appropriate artifact (either JAR for Cloud Foundry
or Docker image for Kubernetes) and we&#8217;re uploading
it to PaaS. <span class="strong"><strong>IMPORTANT</strong></span> the <span class="emphasis"><em>old</em></span> artifact is running against the <span class="strong"><strong>NEW</strong></span> version of the database.</li><li class="listitem">we&#8217;re running the <span class="emphasis"><em>old</em></span> <code class="literal">smoke</code> tests against the freshly deployed application surrounded by stubs.
If those tests pass then we have a high probability that the application is backwards compatible</li><li class="listitem">the default behaviour is that after all of those steps the user can manually click to deploy the
application to a stage environment</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_stage" href="#_stage"></a>2.3&nbsp;Stage</h2></div></div></div><div class="figure"><a name="d0e697" href="#d0e697"></a><p class="title"><b>Figure&nbsp;2.3.&nbsp;End to end tests on stage environment</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/stage.png" alt="stage"></div></div></div><br class="figure-break"><p>Here we&#8217;re</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">starting a RabbitMQ service in PaaS</li><li class="listitem">deploying <code class="literal">Eureka</code> infrastructure application to PaaS</li><li class="listitem">downloading the artifact (either JAR for Cloud Foundry or Docker image for Kubernetes)
from and we&#8217;re uploading it to PaaS.</li></ul></div><p>Next we have a manual step in which:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">from the checked out code we&#8217;re running the tests available under the <code class="literal">e2e</code> profile. In the
case of <code class="literal">GitHub Analytics</code> application we&#8217;re sending a HTTP message to GitHub Analytic&#8217;s endpoint. Then we&#8217;re checking if
the received message count has increased.</li></ul></div><p>The step is manual by default due to the fact that stage environment is often shared between
teams and some preparations on databases / infrastructure have to take place before running the tests.
Ideally these step should be fully automatic.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_prod" href="#_prod"></a>2.4&nbsp;Prod</h2></div></div></div><div class="figure"><a name="d0e738" href="#d0e738"></a><p class="title"><b>Figure&nbsp;2.4.&nbsp;Deployment to production</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/prod.png" alt="prod"></div></div></div><br class="figure-break"><p>The step to deploy to production is manual but ideally it should be automatic.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>This step does deployment to production. On production you would assume
that you have the infrastructure running. That&#8217;s why before you run this step you
must execute a script that will provision the services on the production environment.
For <code class="literal">Cloud Foundry</code> just call <code class="literal">tools/cf-helper.sh setup-prod-infra</code> and
for Kubernetes <code class="literal">tools/k8s-helper.sh setup-prod-infra</code></p></td></tr></table></div><p>Here we&#8217;re</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">tagging the Git repo with <code class="literal">prod/${version}</code> tag</li><li class="listitem">downloading the application artifact (either JAR for Cloud Foundry or Docker image for Kubernetes)</li><li class="listitem">we&#8217;re doing Blue Green deployment:</li><li class="listitem"><p class="simpara">for Cloud Foundry</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">we&#8217;re renaming the current instance of the app e.g. <code class="literal">fooService</code> to <code class="literal">fooService-venerable</code></li><li class="listitem">we&#8217;re deploying the new instance of the app under the <code class="literal">fooService</code> name</li><li class="listitem">now two instances of the same application are running on production</li></ul></div></li><li class="listitem"><p class="simpara">for Kubernetes</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">we&#8217;re deploying a service with the name of the app e.g. <code class="literal">fooService</code></li><li class="listitem">we&#8217;re doing a deployment with the name of the app with version suffix (with the name escaped
to fulfill the DNS name requirements) e.g. <code class="literal">fooService-1-0-0-M1-123-456-VERSION</code></li><li class="listitem">all deployments of the same application have the same label <code class="literal">name</code> equal to app name e.g. <code class="literal">fooService</code></li><li class="listitem">the service is routing the traffic basing on the <code class="literal">name</code> label selector</li><li class="listitem">now two instances of the same application are running on production</li></ul></div></li><li class="listitem"><p class="simpara">in the <code class="literal">Complete switch over</code> which is a manual step</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">we&#8217;re stopping the old instance</li><li class="listitem">remember to run this step only after you have confirmed that both instances are working fine!</li></ul></div></li><li class="listitem"><p class="simpara">in the <code class="literal">Rollback</code> which is a manual step</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p class="simpara">we&#8217;re routing all the traffic to the old instance</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem">in CF we do that by ensuring that blue is running and removing green</li><li class="listitem">in K8S we do that by scaling the number of instances of green to 0</li></ul></div></li><li class="listitem">we&#8217;re removing the latest prod git tag</li></ul></div></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="multi__introduction.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="multi__project_opinions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">1.&nbsp;Introduction&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="multi_spring-cloud-pipelines.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;3.&nbsp;Project opinions</td></tr></table></div></body></html>