<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>1.&nbsp;Introduction</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="multi_spring-cloud-pipelines.html" title="Spring Cloud Pipelines"><link rel="up" href="multi__spring_cloud_pipelines.html" title="Part&nbsp;I.&nbsp;Spring Cloud Pipelines"><link rel="prev" href="multi__spring_cloud_pipelines.html" title="Part&nbsp;I.&nbsp;Spring Cloud Pipelines"><link rel="next" href="multi_how-do-the-scripts-work.html" title="2.&nbsp;How the Scripts Work"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1.&nbsp;Introduction</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="multi__spring_cloud_pipelines.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;I.&nbsp;Spring Cloud Pipelines</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="multi_how-do-the-scripts-work.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_introduction" href="#_introduction"></a>1.&nbsp;Introduction</h2></div></div></div><p>This section describes the rationale
behind the opinionated pipeline. We go through each deployment
step and describe it in detail.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>You do not need to use all the pieces of Spring Cloud Pipelines. You
can (and should) gradually migrate your applications to use those pieces of
Spring Cloud Pipelines that you think best suit your needs.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_five_second_introduction" href="#_five_second_introduction"></a>1.1&nbsp;Five-second Introduction</h2></div></div></div><p>Spring Cloud Pipelines provides scripts, configuration, and convention for automated
deployment pipeline creation for Jenkins and Concourse with Cloud Foundry or Kubernetes.
We support JVM languages, PHP, and NodeJS. Since SC-Pipelines uses bash scripts,
you can use it with whatever automation server you have.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_five_minute_introduction" href="#_five_minute_introduction"></a>1.2&nbsp;Five-minute Introduction</h2></div></div></div><p>Spring Cloud Pipelines comes with bash scripts (available under <code class="literal">common/src/main/bash</code>)
that represent the logic of all steps in our opinionated deployment pipeline.
Since we believe in convention over configuration, for the supported framework and
languages, we assume that the projects follow certain conventions of task naming,
profile setting, and so on. That way, if you create a new application,
your application can follow those conventions and the deployment pipeline works.
Since no one pipeline can serve the purposes of all
teams in a company, we believe that minor deployment pipeline tweaking should take place.
That is why we allow the usage of that <code class="literal">sc-pipelines.yml</code> descriptor, which allows for
provide some customization.</p><p>From the pipeline visualization perspective, we have prepared templates for Concourse
and Jenkins (through the Jenkins Job DSL and Jenkinsfile). That means you can reuse them
immediately to visualize a deployment pipeline. If you use some other tool for
continuous delivery, you can set the visualization yourself and reference the
bash scripts for each step. In other words, Spring Cloud Pipelines can be reused
with any continuous delivery tool.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_to_use_it" href="#_how_to_use_it"></a>1.2.1&nbsp;How to Use It</h3></div></div></div><p>This repository can be treated as a template for your pipeline. We provide some opinionated
implementation that you can alter to suit your needs. To use it, we recommend downloading
the Spring Cloud Pipelines repository as a zip file, unzipping it in a directory,
initializing a Git project in that directory, and then modifying the project to suit your
needs. The following bash script shows how to do so:</p><div class="informalexample"><pre class="programlisting">$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># pass the branch (e.g. master) or a particular tag (e.g. v1.0.0.RELEASE)</span>
$ SC_PIPELINES_RELEASE=...
$ curl -LOk https://github.com/spring-cloud/spring-cloud-pipelines/archive/${SC_PIPELINES_RELEASE}.zip
$ unzip ${SC_PIPELINES_RELEASE}.zip
$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">cd</span> spring-cloud-pipelines-${SC_PIPELINES_RELEASE}
$ git init
$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># modify the pipelines to suit your needs</span>
$ git add .
$ git commit -m <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Initial commit"</span>
$ git remote add origin ${YOUR_REPOSITORY_URL}
$ git push origin master</pre></div><p>To keep your repository aligned with the changes in the upstream repository, you can also
clone the repository. To not have many merge conflicts, we recommend using the <code class="literal">custom</code>
folder hooks to override functions.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_it_works" href="#_how_it_works"></a>1.2.2&nbsp;How It Works</h3></div></div></div><p>As the following image shows, Spring Cloud Pipelines contains logic to generate a
pipeline and the runtime to execute pipeline steps.</p><div class="figure"><a name="d0e77" href="#d0e77"></a><p class="title"><b>Figure&nbsp;1.1.&nbsp;How Spring Cloud Pipelines works</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/how.png" alt="how"></div></div></div><br class="figure-break"><p>Once a pipeline is created (for example, by using the Jenkins Job DSL or from a Concourse
templated pipeline), when the jobs are ran, they clone or download Spring Cloud Pipelines
code to run each step. Those steps run functions that are
defined in the <code class="literal">commons</code> module of Spring Cloud Pipelines.</p><p>Spring Cloud Pipelines performs steps to guess what kind of a project your
repository is (for example, JVM or PHP) and what framework it uses (Maven or Gradle), and it
can deploy your application to a cloud (Cloud Foundry or Kubernetes). You can read about how
it works by reading the <a class="xref" href="multi_how-do-the-scripts-work.html" title="2.&nbsp;How the Scripts Work">Chapter&nbsp;2, <i>How the Scripts Work</i></a> section.</p><p>All of that happens automatically if your application follows the conventions.
You can read about them in the <a class="xref" href="multi_project-opinions.html" title="4.&nbsp;Project Opinions">Chapter&nbsp;4, <i>Project Opinions</i></a> section.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_supported_languages" href="#_supported_languages"></a>1.2.3&nbsp;Supported Languages</h3></div></div></div><p>Currently, we support the following languages:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">JVM</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">Maven wrapper-based project</li><li class="listitem">Gradle wrapper-based project</li></ul></div></li><li class="listitem"><p class="simpara">PHP</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">Composer-based project</li></ul></div></li><li class="listitem">NPM</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_centralized_pipeline_creation" href="#_centralized_pipeline_creation"></a>1.2.4&nbsp;Centralized Pipeline Creation</h3></div></div></div><p>You can use Spring Cloud Pipelines to generate pipelines
for all the projects in your system. You can scan all your
repositories (for example, you can call the Stash or Github API to retrieve the list of repositories)
and then:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">For Jenkins, call the seed job and pass the <code class="literal">REPOS</code>
parameter, which contains the list of repositories.</li><li class="listitem">For Concourse, call <code class="literal">fly</code> and set the
pipeline for every repository.</li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>We recommend using Spring Cloud Pipelines this way.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_a_pipeline_for_each_repository" href="#_a_pipeline_for_each_repository"></a>1.2.5&nbsp;A Pipeline for Each Repository</h3></div></div></div><p>You can use Spring Cloud Pipelines in such a way that
each project contains its own pipeline definition in
its code. Spring Cloud Pipelines clones the code with
the pipeline definitions (the bash scripts), so the
only piece of logic that needs to be in your application&#8217;s
repository is the pipeline definition.</p><p>For Jenkins, you need to either set up the <code class="literal">Jenkinsfile</code>
or the jobs by using the Jenkins Job DSL plugin in your repo.
Then, in Jenkins, whenever you set up a new pipeline for a repository,
you can reference the pipeline definition in that repo.
For Concourse, each project contains its own pipeline steps,
and it is up to the project to set up the pipeline.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_the_flow" href="#_the_flow"></a>1.3&nbsp;The Flow</h2></div></div></div><p>The following images show the flow of the opinionated pipeline:</p><div class="figure"><a name="d0e161" href="#d0e161"></a><p class="title"><b>Figure&nbsp;1.2.&nbsp;Flow in Concourse</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/flow_concourse.png" alt="flow concourse"></div></div></div><br class="figure-break"><div class="figure"><a name="d0e170" href="#d0e170"></a><p class="title"><b>Figure&nbsp;1.3.&nbsp;Flow in Jenkins</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/flow.png" alt="flow"></div></div></div><br class="figure-break"><p>We first describe the overall concept behind the flow and then
split it into pieces and describe each piece independently.</p><p>===Vocabulary</p><p>This section defines some common vocabulary. We describe four typical
environments in terms of running the pipeline.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_environments" href="#_environments"></a>1.3.1&nbsp;Environments</h3></div></div></div><p>We typically encounter the following environments:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="strong"><strong>build</strong></span> environment is a machine where the building of the application takes place.
It is a continuous integration or continuous delivery tool worker.</li><li class="listitem"><span class="strong"><strong>test</strong></span> is an environment where you can deploy an application to test it. It does not
resemble production, because we cannot be sure of its state (which application is deployed
there and in which version). It can be used by multiple teams at the same time.</li><li class="listitem"><span class="strong"><strong>stage</strong></span> is an environment that does resemble production. Most likely, applications
are deployed there in versions that correspond to those deployed to production.
Typically, staging databases hold (often obfuscated) production data. Most
often, this environment is a single environment shared between many teams. In other
words, in order to run some performance and user acceptance tests, you have to block
and wait until the environment is free.</li><li class="listitem"><span class="strong"><strong>prod</strong></span> is the production environment where we want our tested applications to be
deployed for our customers.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_tests" href="#_tests"></a>1.3.2&nbsp;Tests</h3></div></div></div><p>We typically encounter the following kinds of tests:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="strong"><strong>Unit tests</strong></span>: Tests that run on the application during the build phase.
No integrations with databases or HTTP server stubs or other resources take place.
Generally speaking, your application should have plenty of these tests to provide fast
feedback about whether your features work.</li><li class="listitem"><span class="strong"><strong>Integration tests</strong></span>: Tests that run on the built application during the build phase.
Integrations with in-memory databases and HTTP server stubs take place. According to the
<a class="link" href="https://martinfowler.com/bliki/TestPyramid.html" target="_top">test pyramid</a>, in most cases, you should
not have many of these kind of tests.</li><li class="listitem"><span class="strong"><strong>Smoke tests</strong></span>: Tests that run on a deployed application. The concept of these tests
is to check that the crucial parts of your application are working properly. If you have 100 features
in your application but you gain the most money from five features, you could write smoke tests
for those five features. We are talking about smoke tests of an application, not of
the whole system. In our understanding inside the opinionated pipeline, these tests are
executed against an application that is surrounded with stubs.</li><li class="listitem"><span class="strong"><strong>End-to-end tests</strong></span>: Tests that run on a system composed of multiple applications.
These tests ensure that the tested feature works when the whole system is set up.
Due to the fact that it takes a lot of time, effort, and resources to maintain such an environment
and that these tests are often unreliable (due to many different moving pieces, such as network,
database, and others), you should have a handful of those tests. They should be only for critical parts of your business.
Since only production is the key verifier of whether your feature works, some companies
do not even want to have these tests and move directly to deployment to production. When your
system contains KPI monitoring and alerting, you can quickly react when your deployed application
does not behave properly.</li><li class="listitem"><span class="strong"><strong>Performance testing</strong></span>: Tests run on an application or set of applications
to check if your system can handle a big load. In the case of our opinionated pipeline,
these tests can run either on test (against a stubbed environment) or on
staging (against the whole system).</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_testing_against_stubs" href="#_testing_against_stubs"></a>1.3.3&nbsp;Testing against Stubs</h3></div></div></div><p>Before we go into the details of the flow, consider the example described by the following image:</p><div class="figure"><a name="d0e250" href="#d0e250"></a><p class="title"><b>Figure&nbsp;1.4.&nbsp;Two monolithic applications deployed for end to end testing</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/monolith.png" alt="monolith"></div></div></div><br class="figure-break"><p>When you have only a handful of applications, end-to-end testing is beneficial.
From the operations perspective, it is maintainable for a finite number of deployed instances.
From the developers perspective, it is nice to verify the whole flow in the system
for a feature.</p><p>In the case of microservices, the scale starts to be a problem, as the following image shows:</p><div class="figure"><a name="d0e263" href="#d0e263"></a><p class="title"><b>Figure&nbsp;1.5.&nbsp;Many microservices deployed in different versions</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/many_microservices.png" alt="many microservices"></div></div></div><br class="figure-break"><p>The following questions arise:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">Should I queue deployments of microservices on one testing environment or should I have an environment per microservice?</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">If I queue deployments, people have to wait for hours to have their tests run. That can be a problem</li></ul></div></li><li class="listitem"><p class="simpara">To remove that issue, I can have an environment for each microservice.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">Who will pay the bills? (Imagine 100 microservices, each having each own environment).</li><li class="listitem">Who will support each of those environments?</li><li class="listitem">Should we spawn a new environment each time we execute a new pipeline and then wrap it up or should we have
them up and running for the whole day?</li></ul></div></li><li class="listitem"><p class="simpara">In which versions should I deploy the dependent microservices - development or production versions?</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">If I have development versions, I can test my application against a feature that is not yet on production.
That can lead to exceptions in production.</li><li class="listitem">If I test against production versions, I can never test against a feature under development
anytime before deployment to production.</li></ul></div></li></ul></div><p>One of the possibilities of tackling these problems is to not do end-to-end tests.</p><p>The following image shows one solution to the problem, in the form of stubbed dependencies:</p><div class="figure"><a name="d0e309" href="#d0e309"></a><p class="title"><b>Figure&nbsp;1.6.&nbsp;Execute tests on a deployed microservice on stubbed dependencies</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/stubbed_dependencies.png" alt="stubbed dependencies"></div></div></div><br class="figure-break"><p>If we stub out all the dependencies of our application, most of the problems presented earlier
disappear. There is no need to start and setup the infrastructure required by the dependent
microservices. That way, the testing setup looks like the following image:</p><div class="figure"><a name="d0e320" href="#d0e320"></a><p class="title"><b>Figure&nbsp;1.7.&nbsp;We&#8217;re testing microservices in isolation</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/stubbed_dependencies.png" alt="stubbed dependencies"></div></div></div><br class="figure-break"><p>Such an approach to testing and deployment gives the following benefits
(thanks to the usage of <a class="link" href="http://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html" target="_top">Spring Cloud Contract</a>):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">No need to deploy dependent services.</li><li class="listitem">The stubs used for the tests run on a deployed microservice are the same as those used during integration tests.</li><li class="listitem">Those stubs have been tested against the application that produces them (see <a class="link" href="http://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html" target="_top">Spring Cloud Contract</a> for more information).</li><li class="listitem">We do not have many slow tests running on a deployed application, so the pipeline gets executed much faster.</li><li class="listitem">We do not have to queue deployments. We test in isolation so that pipelines do not interfere with each other.</li><li class="listitem">We do not have to spawn virtual machines each time for deployment purposes.</li></ul></div><p>However, this approach brings the following challenges:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">No end-to-end tests before production. You do not have full certainty that a feature is working.</li><li class="listitem">The first time the applications interact in a real way is on production.</li></ul></div><p>As with every solution, it has its benefits and drawbacks. The opinionated pipeline
lets you configure whether you want to follow this flow or not.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_general_view" href="#_general_view"></a>1.3.4&nbsp;General View</h3></div></div></div><p>The general view behind this deployment pipeline is to:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Test the application in isolation.</li><li class="listitem">Test the backwards compatibility of the application, in order to roll it back if necessary.</li><li class="listitem">Allow testing of the packaged application in a deployed environment.</li><li class="listitem">Allow user acceptance tests and performance tests in a deployed environment.</li><li class="listitem">Allow deployment to production.</li></ul></div><p>The pipeline could have been split to more steps, but it seems that all of the aforementioned
actions fit nicely in our opinionated proposal.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_pipeline_descriptor" href="#_pipeline_descriptor"></a>1.4&nbsp;Pipeline Descriptor</h2></div></div></div><p>Each application can contain a file (called <code class="literal">sc-pipelines.yml</code>) with the following structure:</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">language_type</span>: jvm
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">pipeline</span>:
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># used for multi module projects</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">	main_module</span>: things/thing
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># used for multi projects</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">	project_names</span>:
		- monoRepoA
		- monoRepoB
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># should deploy to stage automatically and run e2e tests</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">	auto_stage</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># should deploy to production automatically</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">	auto_prod</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># should the api compatibility check be there</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">	api_compatibility_step</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># should the test rollback step be there</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">	rollback_step</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># should the stage step be there</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">	stage_step</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># should the test step (including rollback) be there</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">	test_step</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">lowercaseEnvironmentName1</span>:
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># used by spinnaker</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">	deployment_strategy</span>: HIGHlANDER
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># list of services to be deployed</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">	services</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">		- type</span>: service1Type
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">		  name</span>: service1Name
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">		  coordinates</span>: value
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">		- type</span>: service2Type
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">		  name</span>: service2Name
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">		  key</span>: value
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">lowercaseEnvironmentName2</span>:
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># used by spinnaker</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">	deployment_strategy</span>: HIGHlANDER
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># list of services to be deployed</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">	services</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">		- type</span>: service3Type
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">		  name</span>: service3Name
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">		  coordinates</span>: value
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">		- type</span>: service4Type
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">		  name</span>: service4Name
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">		  key</span>: value</pre></div><p>If you have a multi-module project, you should point to the folder that contains the
module that produces the fat jar. In the preceding example, that module
would be present under the <code class="literal">things/thing</code> folder. If you have a single module project,
you need not create this section.</p><p>For a given environment, we declare a list of infrastructure services that we
want to have deployed. Services have:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">type</code> (examples: <code class="literal">eureka</code>, <code class="literal">mysql</code>, <code class="literal">rabbitmq</code>, and <code class="literal">stubrunner</code>): This value gets
then applied to the <code class="literal">deployService</code> Bash function</li><li class="listitem"><span class="strong"><strong>[KUBERNETES]</strong></span>: For <code class="literal">mysql</code>, you can pass the database name in the <code class="literal">database</code> property.</li><li class="listitem"><code class="literal">name</code>: The name of the service to get deployed.</li><li class="listitem"><code class="literal">coordinates</code>: The coordinates that let you fetch the binary of the service.
It can be a Maven coordinate (<code class="literal">groupid:artifactid:version</code>),
a docker image (<code class="literal">organization/nameOfImage</code>), and so on.</li><li class="listitem">Arbitrary key value pairs, which let you customize the services as you wish.</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_pipeline_descriptor_for_cloud_foundry" href="#_pipeline_descriptor_for_cloud_foundry"></a>1.4.1&nbsp;Pipeline Descriptor for Cloud Foundry</h3></div></div></div><p>When deploying to Cloud Foundry you can provide services
of the following types:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara"><code class="literal">type: broker</code></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><code class="literal">broker</code>: The name of the CF broker</li><li class="listitem"><code class="literal">plan</code>: The name of the plan</li><li class="listitem"><code class="literal">params</code>: Additional parameters are converted to JSON</li><li class="listitem"><code class="literal">useExisting</code>: Whether to use an existing one or
create a new one (defaults to <code class="literal">false</code>)</li></ul></div></li><li class="listitem"><p class="simpara"><code class="literal">type: app</code></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><code class="literal">coordinates</code>: The Maven coordinates of the stub runner jar</li><li class="listitem"><code class="literal">manifestPath</code>: The path to the manifest for the stub runner jar</li></ul></div></li><li class="listitem"><p class="simpara"><code class="literal">type: cups</code></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><code class="literal">params</code>: Additional parameters are converted to JSON</li></ul></div></li><li class="listitem"><p class="simpara"><code class="literal">type: cupsSyslog</code></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><code class="literal">url</code>: The URL to the syslog drain</li></ul></div></li><li class="listitem"><p class="simpara"><code class="literal">type: cupsRoute</code></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><code class="literal">url</code>: The URL to the route service</li></ul></div></li><li class="listitem"><p class="simpara"><code class="literal">type: stubrunner</code></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><code class="literal">coordinates</code>: The Maven coordinates of the stub runner jar</li><li class="listitem"><code class="literal">manifestPath</code>: The path to the manifest for the stub runner jar</li></ul></div></li></ul></div><p>The following example shows the contents of a YAML file that defines the preceding values:</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># This file describes which services are required by this application</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># in order for the smoke tests on the TEST environment and end to end tests</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># on the STAGE environment to pass</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># lowercase name of the environment</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">test</span>:
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># list of required services</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  services</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    - name</span>: config-server
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      type</span>: broker
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      broker</span>: p-config-server
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      plan</span>: standard
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      params</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/ciberkleid/app-config
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      useExisting</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    - name</span>: cloud-bus
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      type</span>: broker
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      broker</span>: cloudamqp
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      plan</span>: lemur
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      useExisting</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    - name</span>: service-registry
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      type</span>: broker
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      broker</span>: p-service-registry
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      plan</span>: standard
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      useExisting</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    - name</span>: circuit-breaker-dashboard
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      type</span>: broker
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      broker</span>: p-circuit-breaker-dashboard
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      plan</span>: standard
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      useExisting</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    - name</span>: stubrunner
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      type</span>: stubrunner
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      coordinates</span>: io.pivotal:cloudfoundry-stub-runner-boot:<span class="hl-number">0.0</span>.<span class="hl-number">1.</span>M1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      manifestPath</span>: sc-pipelines/manifest-stubrunner.yml

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">stage</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  services</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    - name</span>: config-server
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      type</span>: broker
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      broker</span>: p-config-server
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      plan</span>: standard
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      params</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/ciberkleid/app-config
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    - name</span>: cloud-bus
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      type</span>: broker
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      broker</span>: cloudamqp
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      plan</span>: lemur
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    - name</span>: service-registry
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      type</span>: broker
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      broker</span>: p-service-registry
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      plan</span>: standard
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    - name</span>: circuit-breaker-dashboard
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      type</span>: broker
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      broker</span>: p-circuit-breaker-dashboard
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      plan</span>: standard</pre></div><p>Another CF specific property is <code class="literal">artifact_type</code>. Its value can be either <code class="literal">binary</code> or <code class="literal">source</code>.
Certain languages (such as Java) require a binary to be uploaded, but others (such as PHP)
require you to push the sources. The default value is <code class="literal">binary</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_project_setup" href="#_project_setup"></a>1.5&nbsp;Project Setup</h2></div></div></div><p>Spring Cloud Pipelines supports three main types of project setup:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">Single Project</code></li><li class="listitem"><code class="literal">Multi Module</code></li><li class="listitem"><code class="literal">Multi Project</code> (also known as mono repo)</li></ul></div><p>A <code class="literal">Single Project</code> is a project that contains a single module that gets
built and packaged into a single, executable artifact.</p><p>A <code class="literal">Multi Module</code> project is a project that contains multiple modules.
After building all modules, one gets packaged into a single, executable artifact.
You have to point to that module in your pipeline descriptor.</p><p>A <code class="literal">Multi Project</code> is a project that contains multiple projects. Each of those
projects can in turn be a <code class="literal">Single Project</code> or a <code class="literal">Multi Module</code> project. Spring
Cloud Pipelines assume that, if a <code class="literal">PROJECT_NAME</code> environment
variable corresponds to a folder with the same name in the root of the
repository, this is the project it should build. For example, for
<code class="literal">PROJECT_NAME=something</code>, if there&#8217;s a folder named <code class="literal">something</code>, then Spring Cloud Pipelines
treats the <code class="literal">something</code> directory as the root of the <code class="literal">something</code> project.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="multi__spring_cloud_pipelines.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="multi__spring_cloud_pipelines.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="multi_how-do-the-scripts-work.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;I.&nbsp;Spring Cloud Pipelines&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="multi_spring-cloud-pipelines.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;2.&nbsp;How the Scripts Work</td></tr></table></div></body></html>