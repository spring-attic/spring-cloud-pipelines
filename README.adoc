= Jenkins DSL Pipeline

The repository contains job definitions and the opinionated setup pipeline using https://wiki.jenkins-ci.org/display/JENKINS/Job+DSL+Plugin[Jenkins Job Dsl plugin]. Those jobs will form an empty pipeline and a sample, opinionated one that you can use in your company.

All in all there are the following projects taking part in the whole `microservice setup` for this demo.

- https://github.com/spring-cloud-samples/github-analytics[Github-Analytics] - the app that has a REST endpoint and uses messaging. Our business application.
- https://github.com/spring-cloud-samples/github-webhook[Github Webhook] - project that emits messages that are used by Github Analytics. Our business application.
- https://github.com/spring-cloud-samples/github-eureka[Eureka] - simple Eureka Server. This is an infrastructure application.
- https://github.com/spring-cloud-samples/github-analytics-stub-runner-boot[Github Analytics Stub Runner Boot] - Stub Runner Boot server to be used for tests with Github Analytics. Uses Eureka and Messaging. This is an infrastructure application.

== Step by step

- Fork repos
- Start PCF Dev (if you don't want to use an existing one)
- Start Docker Compose with Jenkins + Artifactory
- Setup Jenkins env vars (if you want to use the demo defaults and you're using Docker Machine
just check out the section on how to update the URL to Artifactory)
- Setup Jenkins miscs (JDK installation, Groovy macro processing etc.)
- Setup Jenkins credentials
- Add `settings.xml` for Jenkins' master (you can skip this if you want to use our defaults)
- Run the seed job
- Run the `github-webhook` pipeline

=== Fork repos

There are 4 apps that are composing the pipeline

  - https://github.com/spring-cloud-samples/github-webook[Github Webhook]
  - https://github.com/spring-cloud-samples/github-analytics/[Github Analytics]
  - https://github.com/spring-cloud-samples/github-eureka[Github Eureka]
  - https://github.com/spring-cloud-samples/github-analytics-stub-runner-boot[Github Stub Runner Boot]

You need to fork only these. That's because only then will your user be able to tag and push the tag to repo.

  - https://github.com/spring-cloud-samples/github-webook[Github Webhook]
  - https://github.com/spring-cloud-samples/github-analytics/[Github Analytics]

For the other two

  - https://github.com/spring-cloud-samples/github-eureka[Github Eureka]
  - https://github.com/spring-cloud-samples/github-analytics-stub-runner-boot[Github Stub Runner Boot]

You have to build locally and upload their artifacts to Artifactory.

==== Remove the tags

If you keep playing around with your repo you might end up with some tags that
point to versions that have not been deployed to your Artifactory. That often happens
when you remove the volume that Artifactory is using. To fix this issue just remove
all the tags.

[source,bash]
----
git tag -l | xargs -n 1 git push --delete origin
----

==== Set up your local Maven to work with Artifactory

First, you have to ensure that this section is present under your `~/.m2/settings.xml`

[source,xml]
----
<server>
  <id>artifactory-local</id>
  <username>admin</username>
  <password>password</password>
</server>
----

If you don't have this file just copy the one under `seed/settings.xml` or copy paste it from below

[source,xml]
----
include::seed/settings.xml[]
----

==== Deploy the infra JARs

If you're running without Docker Machine

Github Eureka:

[source,bash]
----
git clone https://github.com/spring-cloud-samples/github-eureka
cd github-eureka
./mvnw clean deploy
----

Github Stub Runner:

[source,bash]
----
git clone https://github.com/spring-cloud-samples/github-analytics-stub-runner-boot
cd github-analytics-stub-runner-boot
./mvnw clean deploy
----

If you're running with Docker Machine (e.g. Docker Machine running on 192.168.99.100):

Github Eureka:

[source,bash]
----
git clone https://github.com/spring-cloud-samples/github-eureka
cd github-eureka
./mvnw clean deploy -Ddistribution.management.release.url=http://192.168.99.100:8081/artifactory/libs-release-local
----

Github Stub Runner:

[source,bash]
----
git clone https://github.com/spring-cloud-samples/github-analytics-stub-runner-boot
cd github-analytics-stub-runner-boot
./mvnw clean deploy -Ddistribution.management.release.url=http://192.168.99.100:8081/artifactory/libs-release-local
----

=== Start PCF Dev

TIP: You can skip this step if you have CF installed already

You have to download and start PCF Dev. https://pivotal.io/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry-dev/install-pcf-dev[A link how to do it is available here.]

The default credentials when using PCF Dev are:

[source,bash]
----
username: user
password: pass
email: user
org: pcfdev-org
space: pcfdev-space
api: api.local.pcfdev.io
----

You can start the PCF dev with more memory

[source,bash]
----
cf dev start
----

You'll have to create 3 separate spaces (email admin, pass admin)

[source,bash]
----
cf login -a https://api.local.pcfdev.io --skip-ssl-validation -u admin -p admin -o pcfdev-org

cf create-space pcfdev-test
cf set-space-role user pcfdev-org pcfdev-test SpaceDeveloper
cf create-space pcfdev-stage
cf set-space-role user pcfdev-org pcfdev-stage SpaceDeveloper
cf create-space pcfdev-prod
cf set-space-role user pcfdev-org pcfdev-prod SpaceDeveloper
----

IMPORTANT: Most likely you will run out of memory so when reaching the stage
environment it's good to kill all apps on test. You can do it like this:

E.g. for `github-webhook` app

[source,bash]
----
cf target -o pcfdev-org -s pcfdev-test
cf stop github-webhook
cf stop github-eureka
cf stop stubrunner
----

=== Start Docker Compose

Jenkins + Artifactory can be ran locally. To do that just execute

`docker-compose up`

Then Jenkins will be running on port `8080` and Artifactory `8081`.

=== Setup Jenkins env vars

TIP: If you want to only play around with the demo that we've prepared
you can skip this section and use our defaults.

IMPORTANT: If you're choosing the global envs, you *HAVE* to remove the other approach
(e.g. if you set the global env for `REPO_WITH_JARS`, please remove that property in the
seed job

==== Global envs

You can add env vars (go to configure Jenkins -> Global Properties) for the following
 properties (the defaults are for PCF Dev):

Example screen:

image::docs/env_vars.png[]

==== Seed properties

Another approach is to run the seed job with parameters / env vars. Whatever
you set will be parsed by the seed job and passed to the generated Jenkins
jobs.

TIP: This is very useful when the repos you want to build differ. E.g. use
different JDK. Then some seeds can set the `JDK_VERSION` param to one version
of Java installation and the others to another one.

Example screen:

image::docs/seed.png[]

In this example we could parametrize the `REPOS` and `REPO_WITH_JARS` params.

==== All env vars

The env vars that are used in all of the jobs are as follows:

[frame="topbot",options="header,footer"]
|======================
|Property Name  | Property Description | Default value
|CF_TEST_API_URL | The URL to the CF Api for TEST env| api.local.pcfdev.io
|CF_STAGE_API_URL | The URL to the CF Api for STAGE env | api.local.pcfdev.io
|CF_PROD_API_URL | The URL to the CF Api for PROD env | api.local.pcfdev.io
|CF_TEST_ORG    | Name of the org for the test env | pcfdev-org
|CF_TEST_SPACE  | Name of the space for the test env | pcfdev-space
|CF_STAGE_ORG   | Name of the org for the stage env | pcfdev-org
|CF_STAGE_SPACE | Name of the space for the stage env | pcfdev-space
|CF_PROD_ORG   | Name of the org for the prod env | pcfdev-org
|CF_PROD_SPACE | Name of the space for the prod env | pcfdev-space
|REPO_WITH_JARS | URL to repo with the deployed jars | http://artifactory:8081/artifactory/libs-release-local
|M2_SETTINGS_REPO_ID | The id of server from Maven settings.xml | artifactory-local
|JDK_VERSION | The name of the JDK installation | jdk8
|PIPELINE_VERSION | What should be the version of the pipeline (ultimately also version of the jar) | 1.0.0.M1-${GROOVY,script ="new Date().format('yyMMdd_HHmmss')"}-VERSION
|======================

=== Additional setup

==== Enable Groovy Token Macro Processing

you need this to allow generation of Pipeline Version

{nbsp}
{nbsp}

image::docs/manage_jenkins.png[caption="Step 1: ", title="Click 'Manage Jenkins'"]

{nbsp}
{nbsp}

image::docs/configure_system.png[caption="Step 2: ", title="Click 'Configure System'"]

{nbsp}
{nbsp}

image::docs/groovy_token.png[caption="Step 3: ", title="Click 'Allow token macro processing'"]



==== Provide your JDK version

- by default we assume that you have jdk with id `jdk8` configured
- if you want a different one just override `JDK_VERSION` env var and point to the proper one

TIP: The docker image comes in with Java installed at `/usr/lib/jvm/java-8-openjdk-amd64`.
You can go to `Global Tools` and create a JDK with `jdk8` id and JAVA_HOME
 pointing to `/usr/lib/jvm/java-8-openjdk-amd64`

To set the default one just follow these steps:

{nbsp}
{nbsp}

image::docs/manage_jenkins.png[caption="Step 1: ", title="Click 'Manage Jenkins'"]

{nbsp}
{nbsp}

image::docs/global_tool.png[caption="Step 2: ", title="Click 'Global Tool'"]

{nbsp}
{nbsp}

image::docs/jdk_installation.png[caption="Step 3: ", title="Click 'JDK Installations'"]

{nbsp}
{nbsp}

image::docs/jdk.png[caption="Step 4: ", title="Fill out JDK Installation with `/usr/lib/jvm/java-8-openjdk-amd64`"]

{nbsp}
{nbsp}

And that's it!

==== Set Git email / user

{nbsp}
{nbsp}

image::docs/manage_jenkins.png[caption="Step 1: ", title="Click 'Manage Jenkins'"]

{nbsp}
{nbsp}

image::docs/configure_system.png[caption="Step 2: ", title="Click 'Configure System'"]

{nbsp}
{nbsp}

image::docs/git.png[caption="Step 3: ", title="Fill out Git user information"]

{nbsp}
{nbsp}

=== Add Jenkins credentials for GitHub

The scripts will need to access the credentials for Cloud Foundry access.
Additionally there is one that is required in order to tag the repo.

In order for the scripts to find the credentials you have to pass the IDs
of the stored credentials. Below you can find the list of env vars that you
can set in order to find the proper credential. There are of course
some defaults too.

You have to set credentials with ids: `cf-test`, `cf-stage`, `cf-prod`, `git`.

Below you can find instructions on how to set a credential (e.g. for `cf-test` credential).

{nbsp}
{nbsp}

image::docs/credentials_system.png[caption="Step 1: ", title="Click 'Credentials, System'"]

{nbsp}
{nbsp}

image::docs/credentials_global.png[caption="Step 2: ", title="Click 'Global Credentials'"]

{nbsp}
{nbsp}

image::docs/credentials_add.png[caption="Step 3: ", title="Click 'Add credentials'"]

{nbsp}
{nbsp}

image::docs/credentials_example.png[caption="Step 4: ", title="Fill out the user / password and provide the ID (in this example `cf-test`)"]

{nbsp}
{nbsp}

In your scripts we reference the credentials via IDs. These are the defaults for credentials

[frame="topbot",options="header,footer"]
|======================
|Property Name  | Property Description | Default value
|GIT_CREDENTIAL_ID    | Credential ID used to tag a git repo | git
|CF_TEST_CREDENTIAL_ID  | Credential ID for CF Test env access | cf-test
|CF_STAGE_CREDENTIAL_ID   | Credential ID for CF Stage env access | cf-stage
|CF_PROD_CREDENTIAL_ID | Credential ID for CF Prod env access | cf-prod
|======================

If you already have in your system a credential to for example tag a repo
you can use it by passing the value of the property `GIT_CREDENTIAL_ID`

=== Setup settings.xml for Maven deployment

TIP: If you want to use the default connection to the Docker version
of Artifactory you can skip this step

So that `./mvnw deploy` works with Artifactory from Docker we're
already copying the missing `settings.xml` file for you. It looks like this:

[source,xml]
----
<server>
  <id>artifactory-local</id>
  <username>admin</username>
  <password>password</password>
</server>
----

If you want to use your own version of Artifactory / Nexus you have to update
the file (it's in `seed/settings.xml`).

=== Run the seed job

We already create the seed job for you but you'll have to run it. When you do
run it you have to provide some properties. By default we create a seed that
has all the properties options, but you can delete most of it. If you
set the properties as global env variables you have to remove them from the
seed.

Anyways, to run the demo just provide in the `REPOS` var the comma separated
 list of URLs of the 2 aforementioned forks of `github-webhook` and `github-analytics'.

{nbsp}
{nbsp}

image::docs/seed_click.png[caption="Step 1: ", title="Click the 'jenkins-pipeline-seed' job"]

{nbsp}
{nbsp}

image::docs/seed_run.png[caption="Step 2: ", title="Click the 'Build with parameters'"]

{nbsp}
{nbsp}

image::docs/seed.png[caption="Step 3: ", title="Provide the parameters (you'll have more of them)"]

{nbsp}
{nbsp}

image::docs/seed_built.png[caption="Step 4: ", title="This is how the results of seed should look like"]

{nbsp}
{nbsp}

image::docs/seed_views.png[caption="Step 5: ", title="Click the 'github-webhook' view"]

{nbsp}
{nbsp}

image::docs/pipeline_run.png[caption="Step 6: ", title="Run the pipeline"]

{nbsp}
{nbsp}

image::docs/pipeline_run_props.png[caption="Step 7: ", title="You can set some properties (just click 'Build' to proceed) "]

{nbsp}
{nbsp}

image::docs/pipeline_manual.png[caption="Step 8: ", title="Click the manual step to go to stage (remember about killing the apps on test env)"]

{nbsp}
{nbsp}

image::docs/pipeline_finished.png[caption="Step 9: ", title="The full pipeline should look like this"]

{nbsp}
{nbsp}

=== Run the github-webhook pipeline

We already create the seed job for you but you'll have to run it. When you do
run it you have to provide some properties. By default we create a seed that
has all the properties options, but you can delete most of it. If you
set the properties as global env variables you have to remove them from the
seed.

Anyways, to run the demo just provide in the `REPOS` var the comma separated
 list of URLs of the 2 aforementioned forks of `github-webhook` and `github-analytics'.

IMPORTANT: Most likely your 1st build will suddenly hang for 10 minutes. If you rerun it
again it should work after 2-3 minutes. My guess is that it's related to Docker Compose
so sorry for this unfortunate situation.

== FAQ

=== Pipeline version contains ${PIPELINE_VERSION}

You can check the Jenkins logs and you'll see

[source,bash]
----
WARNING: Skipped parameter `PIPELINE_VERSION` as it is undefined on `jenkins-pipeline-sample-build`.
	Set `-Dhudson.model.ParametersAction.keepUndefinedParameters`=true to allow undefined parameters
	to be injected as environment variables or
	`-Dhudson.model.ParametersAction.safeParameters=[comma-separated list]`
	to whitelist specific parameter names, even though it represents a security breach
----

To fix it you have to do exactly what the warning suggests...

=== The build times out with `pipeline.sh` info

Docker compose, docker compose, docker compose... The problem is that for some reason, only in Docker, the execution of
Java hangs. But it hangs randomly and only the first time you try to execute the pipeline.

The solution to this is to run the pipeline again. If once it suddenly, magically passes then
it will pass for any subsequent build.

Another thing that you can try is to run it with plain Docker. Maybe that will help.

=== Can I use the pipeline for some other repos?

Sure! you can pass `REPOS` variable with comma separated list of
`project_name$project_url` format. If you don't provide the PROJECT_NAME the
repo name will be extracted and used as the name of the project.

E.g. for `REPOS` equal to:

`https://github.com/spring-cloud-samples/github-analytics,https://github.com/spring-cloud-samples/github-webhook`

will result in the creation of pipelines with root names `github-analytics` and `github-webhook`.

E.g. for `REPOS` equal to:

`foo$https://github.com/spring-cloud-samples/github-analytics,bar$https://github.com/spring-cloud-samples/atom-feed`

will result in the creation of pipelines with root names `foo` for `github-analytics`
and `bar` for `github-webhook`.

=== Will this work for ANY project?

Not really. This is an `opinionated pipeline` that's why we took some
opinionated decisions like:

- usage of Spring Cloud, Spring Cloud Contract Stub Runner and Spring Cloud Eureka
- usage of Maven Wrapper
- artifacts deployment by `./mvnw clean deploy`
- application deployment to Cloud Foundry
- running smoke tests on a deployed app via the `smoke` Maven profile
- running e2e tests on a deployed app via the `e2e` Maven profile

This is the initial approach that can be easily changed in the future.

=== I've ran out of resources!!

When deploying the app to stage or prod you can get an exception `Insufficient resources`. The way to
 solve it is to kill some apps from test / stage env. To achieve that just call

[source,bash]
----
cf target -o pcfdev-org -s pcfdev-test
cf stop github-webhook
cf stop github-eureka
cf stop stubrunner
----

=== The rollback step fails due to missing JAR ?!

You must have pushed some tags and have removed the Artifactory volume that
contained them. To fix this, just remove the tags

[source,bash]
----
git tag -l | xargs -n 1 git push --delete origin
----

== How to build it

`./gradlew clean build`

WARNING: The ran test only checks if your scripts compile.

== How to use it in Jenkins?

Check out the https://github.com/jenkinsci/job-dsl-plugin/wiki/Tutorial---Using-the-Jenkins-Job-DSL[tutorial].
Provide the link to this repository in your Jenkins installation.

The seed job should scan the `jobs/jenkins_pipeline_sample*.groovy` files.

Remember to add `src/main/groovy` and `src/main/resources` for processing

WARNING: Remember that views can be overridden that's why the suggestion is to contain in one script all the logic needed to build a view
 for a single project (check out that `spring_cloud_views.groovy` is building all the `spring-cloud` views).
